/*
 * Unified report combining DistanceDelayReport, DeliveredMessagesReport, 
 * EventLogReport, and ConnectivityONEReport functionality
 */
package report;

import java.util.HashMap;
import java.util.List;

import core.ConnectionListener;
import core.Coord;
import core.DTNHost;
import core.Message;
import core.MessageListener;
import input.StandardEventsReader;

/**
 * Unified report that combines all four original reports:
 * - DistanceDelayReport: Distance/delay statistics
 * - DeliveredMessagesReport: Delivery information
 * - EventLogReport: Event logging
 * - ConnectivityONEReport: Connection events
 */
public class UnifiedReport extends Report implements ConnectionListener, MessageListener {
    
    // Section headers for different report types
    private static final String DISTANCE_DELAY_HEADER = "# DISTANCE_DELAY_SECTION";
    private static final String DELIVERED_MESSAGES_HEADER = "# DELIVERED_MESSAGES_SECTION";
    private static final String EVENT_LOG_HEADER = "# EVENT_LOG_SECTION";
    private static final String CONNECTIVITY_HEADER = "# CONNECTIVITY_SECTION";
    
    // From DistanceDelayReport
    private HashMap<String, InfoTuple> creationInfos;
    
    // Event type prefixes for easy parsing
    private static final String DD_PREFIX = "DD: ";       // Distance/Delay
    private static final String DM_PREFIX = "DM: ";       // Delivered Messages
    private static final String EL_PREFIX = "EL: ";       // Event Log
    private static final String CO_PREFIX = "CO: ";       // Connectivity
    
    // From EventLogReport constants
    public static final String MESSAGE_TRANS_RELAYED = "R";
    public static final String MESSAGE_TRANS_DELIVERED = "D";
    public static final String MESSAGE_TRANS_DELIVERED_AGAIN = "A";

    public UnifiedReport() {
        init();
    }

    @Override
    protected void init() {
        super.init();
        this.creationInfos = new HashMap<String, InfoTuple>();
        printHeaders();
    }

    /**
     * Print headers for all report sections
     */
    private void printHeaders() {
        write("# Unified Report for Scenario: " + getScenarioName());
        write("# Generated by UnifiedReport combining 4 original reports");
        write("# Report Format:");
        write("# DD: distance_at_send delivery_time hop_count MSG_ID");
        write("# DM: time ID size hopcount deliveryTime fromHost toHost remainingTtl isResponse path");
        write("# EL: time action host1 host2 message extra");
        write("# CO: time CONN host1 host2 up/down");
        write("#");
    }

    // =============================================================================
    // CONNECTION LISTENER METHODS (from ConnectivityONEReport)
    // =============================================================================
    
    public void hostsConnected(DTNHost h1, DTNHost h2) {
        if (isWarmup()) {
            addWarmupID(connectionString(h1, h2));
            return;
        }
        
        // ConnectivityONEReport functionality
        write(CO_PREFIX + createTimeStamp() + " CONN " + connectionString(h1, h2) + " up");
        
        // EventLogReport functionality - use CONNECTION instead of CONN to avoid parsing conflicts
        write(EL_PREFIX + getSimTime() + " " + StandardEventsReader.CONNECTION + 
              " " + h1 + " " + h2 + " " + StandardEventsReader.CONNECTION_UP);
    }

    public void hostsDisconnected(DTNHost h1, DTNHost h2) {
        String conString = connectionString(h1, h2);

        if (isWarmup() || isWarmupID(conString)) {
            removeWarmupID(conString);
            return;
        }

        // ConnectivityONEReport functionality
        write(CO_PREFIX + createTimeStamp() + " CONN " + conString + " down");
        
        // EventLogReport functionality - use CONNECTION instead of CONN to avoid parsing conflicts
        write(EL_PREFIX + getSimTime() + " " + StandardEventsReader.CONNECTION + 
              " " + h1 + " " + h2 + " " + StandardEventsReader.CONNECTION_DOWN);
    }

    // =============================================================================
    // MESSAGE LISTENER METHODS 
    // =============================================================================

    public void messageTransferred(Message m, DTNHost from, DTNHost to, boolean firstDelivery) {
        // EventLogReport functionality
        String extra;
        if (firstDelivery) {
            extra = MESSAGE_TRANS_DELIVERED;
        } else if (to == m.getTo()) {
            extra = MESSAGE_TRANS_DELIVERED_AGAIN;
        } else {
            extra = MESSAGE_TRANS_RELAYED;
        }
        write(EL_PREFIX + getSimTime() + " " + StandardEventsReader.DELIVERED + 
              " " + from + " " + to + " " + m + " " + extra);

        // DeliveredMessagesReport functionality (only for first deliveries)
        if (!isWarmupID(m.getId()) && firstDelivery) {
            int ttl = m.getTtl();
            write(DM_PREFIX + format(getSimTime()) + " " + m.getId() + " " +
                  m.getSize() + " " + m.getHopCount() + " " +
                  format(getSimTime() - m.getCreationTime()) + " " +
                  m.getFrom() + " " + m.getTo() + " " +
                  (ttl != Integer.MAX_VALUE ? ttl : "n/a") +
                  (m.isResponse() ? " Y " : " N ") + getPathString(m));
        }

        // DistanceDelayReport functionality (only for first deliveries)
        if (isWarmupID(m.getId()) || !firstDelivery) {
            return;
        }

        InfoTuple info = this.creationInfos.remove(m.getId());
        if (info != null) {
            write(DD_PREFIX + format(info.getLoc1().distance(info.getLoc2())) + " " +
                  format(getSimTime() - info.getTime()) + " " + 
                  (m.getHops().size()-1) + " " + m.getId());
        }
    }

    public void newMessage(Message m) {
        write(EL_PREFIX + getSimTime() + " " + StandardEventsReader.CREATE + 
              " " + m.getFrom() + " " + m.getTo() + " " + m);

        // DistanceDelayReport and DeliveredMessagesReport functionality
        if (isWarmup()) {
            addWarmupID(m.getId());
            return;
        }

        // Store creation info for distance/delay calculation
        this.creationInfos.put(m.getId(),
                new InfoTuple(getSimTime(),
                        m.getFrom().getLocation().clone(),
                        m.getTo().getLocation().clone()));
    }

    public void messageDeleted(Message m, DTNHost where, boolean dropped) {
        // EventLogReport functionality
        write(EL_PREFIX + getSimTime() + " " + 
              (dropped ? StandardEventsReader.DROP : StandardEventsReader.REMOVE) + 
              " " + where + " " + m);
    }

    public void messageTransferAborted(Message m, DTNHost from, DTNHost to) {
        // EventLogReport functionality
        write(EL_PREFIX + getSimTime() + " " + StandardEventsReader.ABORT + 
              " " + from + " " + to + " " + m);
    }

    public void messageTransferStarted(Message m, DTNHost from, DTNHost to) {
        // EventLogReport functionality
        write(EL_PREFIX + getSimTime() + " " + StandardEventsReader.SEND + 
              " " + from + " " + to + " " + m);
    }

    // =============================================================================
    // UTILITY METHODS
    // =============================================================================

    /**
     * Creates time stamp for connectivity events
     */
    private String createTimeStamp() {
        return String.format("%.2f", getSimTime());
    }

    /**
     * Creates connection string with lower address first
     */
    private String connectionString(DTNHost h1, DTNHost h2) {
        if (h1.getAddress() < h2.getAddress()) {
            return h1.getAddress() + " " + h2.getAddress();
        } else {
            return h2.getAddress() + " " + h1.getAddress();
        }
    }

    /**
     * Returns the message hop path as a string
     */
    private String getPathString(Message m) {
        List<DTNHost> hops = m.getHops();
        String str = m.getFrom().toString();

        for (int i = 1; i < hops.size(); i++) {
            str += "->" + hops.get(i);
        }
        return str;
    }

    @Override
    public void done() {
        // Report undelivered messages (from DistanceDelayReport)
        for (String id : creationInfos.keySet()) {
            InfoTuple info = creationInfos.get(id);
            write(DD_PREFIX + format(info.getLoc1().distance(info.getLoc2())) + 
                  " -1 -1 " + id);
        }
        super.done();
    }

    /**
     * Private class for storing creation time and location info
     */
    private class InfoTuple {
        private double time;
        private Coord loc1;
        private Coord loc2;

        public InfoTuple(double time, Coord loc1, Coord loc2) {
            this.time = time;
            this.loc1 = loc1;
            this.loc2 = loc2;
        }

        public Coord getLoc1() { return loc1; }
        public Coord getLoc2() { return loc2; }
        public double getTime() { return time; }
    }
}